<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - geometry - terrain</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background-color: #bfd1e5;
            color: #61443e;
        }

        a {
            color: #a06851;
        }

        #container,
        body {
            overflow: hidden;
        }
    </style>

    <script src="./js/vendor/three.js"></script>
    <script src="./js/vendor/BufferGeometryUtils.js"></script>

    <script src="./js/vendor/OrbitControls.js"></script>
    <script src="./js/vendor/FlyControls.js"></script>
    <script src="./js/vendor/FirstPersonControls.js"></script>

    <script src="./js/vendor/Perlin.js"></script>

    <script src="./js/terrain/TerrainPatch.js"></script>
    <script src="./js/terrain/TerrainGenerator.js"></script>
    <script src="./js/water/Water.js"></script>


</head>

<body>

    <div id="container"></div>

    <script type="module">

        var container;

        var camera, controls, scene, renderer;

        var mesh;

        var clock = new THREE.Clock();

        var terrainGenerator;

        init();
        animate();

        function init() {

            container = document.getElementById('container');

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            // scene.fog = new THREE.Fog(0x333333, 5000, 10000);

            camera.position.x = 0;
            camera.position.y = 0;
            camera.position.z = 4000;
            camera.up = new THREE.Vector3(0, 0, 1);

            var cylinderGeometry = new THREE.CylinderGeometry(50, 50, 1000, 32);
            var cylinderMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            var cylinderMesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinderMesh.rotation.x = Math.PI / 2;
            scene.add(cylinderMesh);


            var widthPatches = 5, depthPatches = 5;
            var patchWidth = 1000, patchDepth = 1000;
            var totalWidth = patchWidth * widthPatches;
            var totalDepth = patchDepth * depthPatches;

            terrainGenerator = new TerrainGenerator(scene, widthPatches, depthPatches, patchWidth, patchDepth);
            terrainGenerator.updateTerrain(camera.position);


            // var waterLevel = terrainGenerator.waterLevel;
            // var water = new Water(totalWidth / 2, totalDepth / 2, waterLevel, totalWidth, totalDepth, 2, 2);
            // water.addWaterToScene(scene);
            // terrainGenerator.addCombinedTerrainToScene(scene);


            console.log(camera.position);

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);

            controls.target = new THREE.Vector3(0, 0, 0);
            // controls = new FlyControls(camera, renderer.domElement);

            // controls.movementSpeed = 1000;
            // controls.domElement = renderer.domElement;
            // controls.rollSpeed = Math.PI / 24;
            // controls.autoForward = false;
            // controls.dragToLook = false;

            const ambientLight = new THREE.HemisphereLight(0xddeeff, 0x0f0e0d, 3);

            scene.add(ambientLight);

            window.addEventListener('resize', onWindowResize, false);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function animate() {

            requestAnimationFrame(animate);

            render();

        }

        function render() {

            terrainGenerator.updateTerrain(camera.position);

            controls.update(clock.getDelta());
            renderer.render(scene, camera);

        }

    </script>

</body>

</html>